{"ast":null,"code":"\"use client\";\n\n// src/roving-focus-group.tsx\nimport _objectWithoutProperties from \"/Users/sujanbhusal/Downloads/agente/gearupf/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _objectSpread from \"/Users/sujanbhusal/Downloads/agente/gearupf/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nconst _excluded = [\"__scopeRovingFocusGroup\", \"orientation\", \"loop\", \"dir\", \"currentTabStopId\", \"defaultCurrentTabStopId\", \"onCurrentTabStopIdChange\", \"onEntryFocus\", \"preventScrollOnEntryFocus\"],\n  _excluded2 = [\"__scopeRovingFocusGroup\", \"focusable\", \"active\", \"tabStopId\", \"children\"];\nimport * as React from \"react\";\nimport { composeEventHandlers } from \"@radix-ui/primitive\";\nimport { createCollection } from \"@radix-ui/react-collection\";\nimport { useComposedRefs } from \"@radix-ui/react-compose-refs\";\nimport { createContextScope } from \"@radix-ui/react-context\";\nimport { useId } from \"@radix-ui/react-id\";\nimport { Primitive } from \"@radix-ui/react-primitive\";\nimport { useCallbackRef } from \"@radix-ui/react-use-callback-ref\";\nimport { useControllableState } from \"@radix-ui/react-use-controllable-state\";\nimport { useDirection } from \"@radix-ui/react-direction\";\nimport { jsx } from \"react/jsx-runtime\";\nvar ENTRY_FOCUS = \"rovingFocusGroup.onEntryFocus\";\nvar EVENT_OPTIONS = {\n  bubbles: false,\n  cancelable: true\n};\nvar GROUP_NAME = \"RovingFocusGroup\";\nvar [Collection, useCollection, createCollectionScope] = createCollection(GROUP_NAME);\nvar [createRovingFocusGroupContext, createRovingFocusGroupScope] = createContextScope(GROUP_NAME, [createCollectionScope]);\nvar [RovingFocusProvider, useRovingFocusContext] = createRovingFocusGroupContext(GROUP_NAME);\nvar RovingFocusGroup = React.forwardRef((props, forwardedRef) => {\n  return /* @__PURE__ */jsx(Collection.Provider, {\n    scope: props.__scopeRovingFocusGroup,\n    children: /* @__PURE__ */jsx(Collection.Slot, {\n      scope: props.__scopeRovingFocusGroup,\n      children: /* @__PURE__ */jsx(RovingFocusGroupImpl, _objectSpread(_objectSpread({}, props), {}, {\n        ref: forwardedRef\n      }))\n    })\n  });\n});\nRovingFocusGroup.displayName = GROUP_NAME;\nvar RovingFocusGroupImpl = React.forwardRef((props, forwardedRef) => {\n  const {\n      __scopeRovingFocusGroup,\n      orientation,\n      loop = false,\n      dir,\n      currentTabStopId: currentTabStopIdProp,\n      defaultCurrentTabStopId,\n      onCurrentTabStopIdChange,\n      onEntryFocus,\n      preventScrollOnEntryFocus = false\n    } = props,\n    groupProps = _objectWithoutProperties(props, _excluded);\n  const ref = React.useRef(null);\n  const composedRefs = useComposedRefs(forwardedRef, ref);\n  const direction = useDirection(dir);\n  const [currentTabStopId, setCurrentTabStopId] = useControllableState({\n    prop: currentTabStopIdProp,\n    defaultProp: defaultCurrentTabStopId !== null && defaultCurrentTabStopId !== void 0 ? defaultCurrentTabStopId : null,\n    onChange: onCurrentTabStopIdChange,\n    caller: GROUP_NAME\n  });\n  const [isTabbingBackOut, setIsTabbingBackOut] = React.useState(false);\n  const handleEntryFocus = useCallbackRef(onEntryFocus);\n  const getItems = useCollection(__scopeRovingFocusGroup);\n  const isClickFocusRef = React.useRef(false);\n  const [focusableItemsCount, setFocusableItemsCount] = React.useState(0);\n  React.useEffect(() => {\n    const node = ref.current;\n    if (node) {\n      node.addEventListener(ENTRY_FOCUS, handleEntryFocus);\n      return () => node.removeEventListener(ENTRY_FOCUS, handleEntryFocus);\n    }\n  }, [handleEntryFocus]);\n  return /* @__PURE__ */jsx(RovingFocusProvider, {\n    scope: __scopeRovingFocusGroup,\n    orientation,\n    dir: direction,\n    loop,\n    currentTabStopId,\n    onItemFocus: React.useCallback(tabStopId => setCurrentTabStopId(tabStopId), [setCurrentTabStopId]),\n    onItemShiftTab: React.useCallback(() => setIsTabbingBackOut(true), []),\n    onFocusableItemAdd: React.useCallback(() => setFocusableItemsCount(prevCount => prevCount + 1), []),\n    onFocusableItemRemove: React.useCallback(() => setFocusableItemsCount(prevCount => prevCount - 1), []),\n    children: /* @__PURE__ */jsx(Primitive.div, _objectSpread(_objectSpread({\n      tabIndex: isTabbingBackOut || focusableItemsCount === 0 ? -1 : 0,\n      \"data-orientation\": orientation\n    }, groupProps), {}, {\n      ref: composedRefs,\n      style: _objectSpread({\n        outline: \"none\"\n      }, props.style),\n      onMouseDown: composeEventHandlers(props.onMouseDown, () => {\n        isClickFocusRef.current = true;\n      }),\n      onFocus: composeEventHandlers(props.onFocus, event => {\n        const isKeyboardFocus = !isClickFocusRef.current;\n        if (event.target === event.currentTarget && isKeyboardFocus && !isTabbingBackOut) {\n          const entryFocusEvent = new CustomEvent(ENTRY_FOCUS, EVENT_OPTIONS);\n          event.currentTarget.dispatchEvent(entryFocusEvent);\n          if (!entryFocusEvent.defaultPrevented) {\n            const items = getItems().filter(item => item.focusable);\n            const activeItem = items.find(item => item.active);\n            const currentItem = items.find(item => item.id === currentTabStopId);\n            const candidateItems = [activeItem, currentItem, ...items].filter(Boolean);\n            const candidateNodes = candidateItems.map(item => item.ref.current);\n            focusFirst(candidateNodes, preventScrollOnEntryFocus);\n          }\n        }\n        isClickFocusRef.current = false;\n      }),\n      onBlur: composeEventHandlers(props.onBlur, () => setIsTabbingBackOut(false))\n    }))\n  });\n});\nvar ITEM_NAME = \"RovingFocusGroupItem\";\nvar RovingFocusGroupItem = React.forwardRef((props, forwardedRef) => {\n  const {\n      __scopeRovingFocusGroup,\n      focusable = true,\n      active = false,\n      tabStopId,\n      children\n    } = props,\n    itemProps = _objectWithoutProperties(props, _excluded2);\n  const autoId = useId();\n  const id = tabStopId || autoId;\n  const context = useRovingFocusContext(ITEM_NAME, __scopeRovingFocusGroup);\n  const isCurrentTabStop = context.currentTabStopId === id;\n  const getItems = useCollection(__scopeRovingFocusGroup);\n  const {\n    onFocusableItemAdd,\n    onFocusableItemRemove,\n    currentTabStopId\n  } = context;\n  React.useEffect(() => {\n    if (focusable) {\n      onFocusableItemAdd();\n      return () => onFocusableItemRemove();\n    }\n  }, [focusable, onFocusableItemAdd, onFocusableItemRemove]);\n  return /* @__PURE__ */jsx(Collection.ItemSlot, {\n    scope: __scopeRovingFocusGroup,\n    id,\n    focusable,\n    active,\n    children: /* @__PURE__ */jsx(Primitive.span, _objectSpread(_objectSpread({\n      tabIndex: isCurrentTabStop ? 0 : -1,\n      \"data-orientation\": context.orientation\n    }, itemProps), {}, {\n      ref: forwardedRef,\n      onMouseDown: composeEventHandlers(props.onMouseDown, event => {\n        if (!focusable) event.preventDefault();else context.onItemFocus(id);\n      }),\n      onFocus: composeEventHandlers(props.onFocus, () => context.onItemFocus(id)),\n      onKeyDown: composeEventHandlers(props.onKeyDown, event => {\n        if (event.key === \"Tab\" && event.shiftKey) {\n          context.onItemShiftTab();\n          return;\n        }\n        if (event.target !== event.currentTarget) return;\n        const focusIntent = getFocusIntent(event, context.orientation, context.dir);\n        if (focusIntent !== void 0) {\n          if (event.metaKey || event.ctrlKey || event.altKey || event.shiftKey) return;\n          event.preventDefault();\n          const items = getItems().filter(item => item.focusable);\n          let candidateNodes = items.map(item => item.ref.current);\n          if (focusIntent === \"last\") candidateNodes.reverse();else if (focusIntent === \"prev\" || focusIntent === \"next\") {\n            if (focusIntent === \"prev\") candidateNodes.reverse();\n            const currentIndex = candidateNodes.indexOf(event.currentTarget);\n            candidateNodes = context.loop ? wrapArray(candidateNodes, currentIndex + 1) : candidateNodes.slice(currentIndex + 1);\n          }\n          setTimeout(() => focusFirst(candidateNodes));\n        }\n      }),\n      children: typeof children === \"function\" ? children({\n        isCurrentTabStop,\n        hasTabStop: currentTabStopId != null\n      }) : children\n    }))\n  });\n});\nRovingFocusGroupItem.displayName = ITEM_NAME;\nvar MAP_KEY_TO_FOCUS_INTENT = {\n  ArrowLeft: \"prev\",\n  ArrowUp: \"prev\",\n  ArrowRight: \"next\",\n  ArrowDown: \"next\",\n  PageUp: \"first\",\n  Home: \"first\",\n  PageDown: \"last\",\n  End: \"last\"\n};\nfunction getDirectionAwareKey(key, dir) {\n  if (dir !== \"rtl\") return key;\n  return key === \"ArrowLeft\" ? \"ArrowRight\" : key === \"ArrowRight\" ? \"ArrowLeft\" : key;\n}\nfunction getFocusIntent(event, orientation, dir) {\n  const key = getDirectionAwareKey(event.key, dir);\n  if (orientation === \"vertical\" && [\"ArrowLeft\", \"ArrowRight\"].includes(key)) return void 0;\n  if (orientation === \"horizontal\" && [\"ArrowUp\", \"ArrowDown\"].includes(key)) return void 0;\n  return MAP_KEY_TO_FOCUS_INTENT[key];\n}\nfunction focusFirst(candidates) {\n  let preventScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;\n  for (const candidate of candidates) {\n    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;\n    candidate.focus({\n      preventScroll\n    });\n    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;\n  }\n}\nfunction wrapArray(array, startIndex) {\n  return array.map((_, index) => array[(startIndex + index) % array.length]);\n}\nvar Root = RovingFocusGroup;\nvar Item = RovingFocusGroupItem;\nexport { Item, Root, RovingFocusGroup, RovingFocusGroupItem, createRovingFocusGroupScope };","map":{"version":3,"names":["React","composeEventHandlers","createCollection","useComposedRefs","createContextScope","useId","Primitive","useCallbackRef","useControllableState","useDirection","jsx","ENTRY_FOCUS","EVENT_OPTIONS","bubbles","cancelable","GROUP_NAME","Collection","useCollection","createCollectionScope","createRovingFocusGroupContext","createRovingFocusGroupScope","RovingFocusProvider","useRovingFocusContext","RovingFocusGroup","forwardRef","props","forwardedRef","Provider","scope","__scopeRovingFocusGroup","children","Slot","RovingFocusGroupImpl","_objectSpread","ref","displayName","orientation","loop","dir","currentTabStopId","currentTabStopIdProp","defaultCurrentTabStopId","onCurrentTabStopIdChange","onEntryFocus","preventScrollOnEntryFocus","groupProps","_objectWithoutProperties","_excluded","useRef","composedRefs","direction","setCurrentTabStopId","prop","defaultProp","onChange","caller","isTabbingBackOut","setIsTabbingBackOut","useState","handleEntryFocus","getItems","isClickFocusRef","focusableItemsCount","setFocusableItemsCount","useEffect","node","current","addEventListener","removeEventListener","onItemFocus","useCallback","tabStopId","onItemShiftTab","onFocusableItemAdd","prevCount","onFocusableItemRemove","div","tabIndex","style","outline","onMouseDown","onFocus","event","isKeyboardFocus","target","currentTarget","entryFocusEvent","CustomEvent","dispatchEvent","defaultPrevented","items","filter","item","focusable","activeItem","find","active","currentItem","id","candidateItems","Boolean","candidateNodes","map","focusFirst","onBlur","ITEM_NAME","RovingFocusGroupItem","itemProps","_excluded2","autoId","context","isCurrentTabStop","ItemSlot","span","preventDefault","onKeyDown","key","shiftKey","focusIntent","getFocusIntent","metaKey","ctrlKey","altKey","reverse","currentIndex","indexOf","wrapArray","slice","setTimeout","hasTabStop","MAP_KEY_TO_FOCUS_INTENT","ArrowLeft","ArrowUp","ArrowRight","ArrowDown","PageUp","Home","PageDown","End","getDirectionAwareKey","includes","candidates","preventScroll","arguments","length","undefined","PREVIOUSLY_FOCUSED_ELEMENT","document","activeElement","candidate","focus","array","startIndex","_","index","Root","Item"],"sources":["/Users/sujanbhusal/Downloads/agente/gearupf/node_modules/@radix-ui/react-roving-focus/src/roving-focus-group.tsx"],"sourcesContent":["import * as React from 'react';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { createCollection } from '@radix-ui/react-collection';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { useId } from '@radix-ui/react-id';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\nimport { useDirection } from '@radix-ui/react-direction';\n\nimport type { Scope } from '@radix-ui/react-context';\n\nconst ENTRY_FOCUS = 'rovingFocusGroup.onEntryFocus';\nconst EVENT_OPTIONS = { bubbles: false, cancelable: true };\n\n/* -------------------------------------------------------------------------------------------------\n * RovingFocusGroup\n * -----------------------------------------------------------------------------------------------*/\n\nconst GROUP_NAME = 'RovingFocusGroup';\n\ntype ItemData = { id: string; focusable: boolean; active: boolean };\nconst [Collection, useCollection, createCollectionScope] = createCollection<\n  HTMLSpanElement,\n  ItemData\n>(GROUP_NAME);\n\ntype ScopedProps<P> = P & { __scopeRovingFocusGroup?: Scope };\nconst [createRovingFocusGroupContext, createRovingFocusGroupScope] = createContextScope(\n  GROUP_NAME,\n  [createCollectionScope]\n);\n\ntype Orientation = React.AriaAttributes['aria-orientation'];\ntype Direction = 'ltr' | 'rtl';\n\ninterface RovingFocusGroupOptions {\n  /**\n   * The orientation of the group.\n   * Mainly so arrow navigation is done accordingly (left & right vs. up & down)\n   */\n  orientation?: Orientation;\n  /**\n   * The direction of navigation between items.\n   */\n  dir?: Direction;\n  /**\n   * Whether keyboard navigation should loop around\n   * @defaultValue false\n   */\n  loop?: boolean;\n}\n\ntype RovingContextValue = RovingFocusGroupOptions & {\n  currentTabStopId: string | null;\n  onItemFocus(tabStopId: string): void;\n  onItemShiftTab(): void;\n  onFocusableItemAdd(): void;\n  onFocusableItemRemove(): void;\n};\n\nconst [RovingFocusProvider, useRovingFocusContext] =\n  createRovingFocusGroupContext<RovingContextValue>(GROUP_NAME);\n\ntype RovingFocusGroupElement = RovingFocusGroupImplElement;\ninterface RovingFocusGroupProps extends RovingFocusGroupImplProps {}\n\nconst RovingFocusGroup = React.forwardRef<RovingFocusGroupElement, RovingFocusGroupProps>(\n  (props: ScopedProps<RovingFocusGroupProps>, forwardedRef) => {\n    return (\n      <Collection.Provider scope={props.__scopeRovingFocusGroup}>\n        <Collection.Slot scope={props.__scopeRovingFocusGroup}>\n          <RovingFocusGroupImpl {...props} ref={forwardedRef} />\n        </Collection.Slot>\n      </Collection.Provider>\n    );\n  }\n);\n\nRovingFocusGroup.displayName = GROUP_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\ntype RovingFocusGroupImplElement = React.ComponentRef<typeof Primitive.div>;\ntype PrimitiveDivProps = React.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface RovingFocusGroupImplProps\n  extends Omit<PrimitiveDivProps, 'dir'>,\n    RovingFocusGroupOptions {\n  currentTabStopId?: string | null;\n  defaultCurrentTabStopId?: string;\n  onCurrentTabStopIdChange?: (tabStopId: string | null) => void;\n  onEntryFocus?: (event: Event) => void;\n  preventScrollOnEntryFocus?: boolean;\n}\n\nconst RovingFocusGroupImpl = React.forwardRef<\n  RovingFocusGroupImplElement,\n  RovingFocusGroupImplProps\n>((props: ScopedProps<RovingFocusGroupImplProps>, forwardedRef) => {\n  const {\n    __scopeRovingFocusGroup,\n    orientation,\n    loop = false,\n    dir,\n    currentTabStopId: currentTabStopIdProp,\n    defaultCurrentTabStopId,\n    onCurrentTabStopIdChange,\n    onEntryFocus,\n    preventScrollOnEntryFocus = false,\n    ...groupProps\n  } = props;\n  const ref = React.useRef<RovingFocusGroupImplElement>(null);\n  const composedRefs = useComposedRefs(forwardedRef, ref);\n  const direction = useDirection(dir);\n  const [currentTabStopId, setCurrentTabStopId] = useControllableState({\n    prop: currentTabStopIdProp,\n    defaultProp: defaultCurrentTabStopId ?? null,\n    onChange: onCurrentTabStopIdChange,\n    caller: GROUP_NAME,\n  });\n  const [isTabbingBackOut, setIsTabbingBackOut] = React.useState(false);\n  const handleEntryFocus = useCallbackRef(onEntryFocus);\n  const getItems = useCollection(__scopeRovingFocusGroup);\n  const isClickFocusRef = React.useRef(false);\n  const [focusableItemsCount, setFocusableItemsCount] = React.useState(0);\n\n  React.useEffect(() => {\n    const node = ref.current;\n    if (node) {\n      node.addEventListener(ENTRY_FOCUS, handleEntryFocus);\n      return () => node.removeEventListener(ENTRY_FOCUS, handleEntryFocus);\n    }\n  }, [handleEntryFocus]);\n\n  return (\n    <RovingFocusProvider\n      scope={__scopeRovingFocusGroup}\n      orientation={orientation}\n      dir={direction}\n      loop={loop}\n      currentTabStopId={currentTabStopId}\n      onItemFocus={React.useCallback(\n        (tabStopId) => setCurrentTabStopId(tabStopId),\n        [setCurrentTabStopId]\n      )}\n      onItemShiftTab={React.useCallback(() => setIsTabbingBackOut(true), [])}\n      onFocusableItemAdd={React.useCallback(\n        () => setFocusableItemsCount((prevCount) => prevCount + 1),\n        []\n      )}\n      onFocusableItemRemove={React.useCallback(\n        () => setFocusableItemsCount((prevCount) => prevCount - 1),\n        []\n      )}\n    >\n      <Primitive.div\n        tabIndex={isTabbingBackOut || focusableItemsCount === 0 ? -1 : 0}\n        data-orientation={orientation}\n        {...groupProps}\n        ref={composedRefs}\n        style={{ outline: 'none', ...props.style }}\n        onMouseDown={composeEventHandlers(props.onMouseDown, () => {\n          isClickFocusRef.current = true;\n        })}\n        onFocus={composeEventHandlers(props.onFocus, (event) => {\n          // We normally wouldn't need this check, because we already check\n          // that the focus is on the current target and not bubbling to it.\n          // We do this because Safari doesn't focus buttons when clicked, and\n          // instead, the wrapper will get focused and not through a bubbling event.\n          const isKeyboardFocus = !isClickFocusRef.current;\n\n          if (event.target === event.currentTarget && isKeyboardFocus && !isTabbingBackOut) {\n            const entryFocusEvent = new CustomEvent(ENTRY_FOCUS, EVENT_OPTIONS);\n            event.currentTarget.dispatchEvent(entryFocusEvent);\n\n            if (!entryFocusEvent.defaultPrevented) {\n              const items = getItems().filter((item) => item.focusable);\n              const activeItem = items.find((item) => item.active);\n              const currentItem = items.find((item) => item.id === currentTabStopId);\n              const candidateItems = [activeItem, currentItem, ...items].filter(\n                Boolean\n              ) as typeof items;\n              const candidateNodes = candidateItems.map((item) => item.ref.current!);\n              focusFirst(candidateNodes, preventScrollOnEntryFocus);\n            }\n          }\n\n          isClickFocusRef.current = false;\n        })}\n        onBlur={composeEventHandlers(props.onBlur, () => setIsTabbingBackOut(false))}\n      />\n    </RovingFocusProvider>\n  );\n});\n\n/* -------------------------------------------------------------------------------------------------\n * RovingFocusGroupItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst ITEM_NAME = 'RovingFocusGroupItem';\n\ntype RovingFocusItemElement = React.ComponentRef<typeof Primitive.span>;\ntype PrimitiveSpanProps = React.ComponentPropsWithoutRef<typeof Primitive.span>;\ninterface RovingFocusItemProps extends Omit<PrimitiveSpanProps, 'children'> {\n  tabStopId?: string;\n  focusable?: boolean;\n  active?: boolean;\n  children?:\n    | React.ReactNode\n    | ((props: { hasTabStop: boolean; isCurrentTabStop: boolean }) => React.ReactNode);\n}\n\nconst RovingFocusGroupItem = React.forwardRef<RovingFocusItemElement, RovingFocusItemProps>(\n  (props: ScopedProps<RovingFocusItemProps>, forwardedRef) => {\n    const {\n      __scopeRovingFocusGroup,\n      focusable = true,\n      active = false,\n      tabStopId,\n      children,\n      ...itemProps\n    } = props;\n    const autoId = useId();\n    const id = tabStopId || autoId;\n    const context = useRovingFocusContext(ITEM_NAME, __scopeRovingFocusGroup);\n    const isCurrentTabStop = context.currentTabStopId === id;\n    const getItems = useCollection(__scopeRovingFocusGroup);\n\n    const { onFocusableItemAdd, onFocusableItemRemove, currentTabStopId } = context;\n\n    React.useEffect(() => {\n      if (focusable) {\n        onFocusableItemAdd();\n        return () => onFocusableItemRemove();\n      }\n    }, [focusable, onFocusableItemAdd, onFocusableItemRemove]);\n\n    return (\n      <Collection.ItemSlot\n        scope={__scopeRovingFocusGroup}\n        id={id}\n        focusable={focusable}\n        active={active}\n      >\n        <Primitive.span\n          tabIndex={isCurrentTabStop ? 0 : -1}\n          data-orientation={context.orientation}\n          {...itemProps}\n          ref={forwardedRef}\n          onMouseDown={composeEventHandlers(props.onMouseDown, (event) => {\n            // We prevent focusing non-focusable items on `mousedown`.\n            // Even though the item has tabIndex={-1}, that only means take it out of the tab order.\n            if (!focusable) event.preventDefault();\n            // Safari doesn't focus a button when clicked so we run our logic on mousedown also\n            else context.onItemFocus(id);\n          })}\n          onFocus={composeEventHandlers(props.onFocus, () => context.onItemFocus(id))}\n          onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n            if (event.key === 'Tab' && event.shiftKey) {\n              context.onItemShiftTab();\n              return;\n            }\n\n            if (event.target !== event.currentTarget) return;\n\n            const focusIntent = getFocusIntent(event, context.orientation, context.dir);\n\n            if (focusIntent !== undefined) {\n              if (event.metaKey || event.ctrlKey || event.altKey || event.shiftKey) return;\n              event.preventDefault();\n              const items = getItems().filter((item) => item.focusable);\n              let candidateNodes = items.map((item) => item.ref.current!);\n\n              if (focusIntent === 'last') candidateNodes.reverse();\n              else if (focusIntent === 'prev' || focusIntent === 'next') {\n                if (focusIntent === 'prev') candidateNodes.reverse();\n                const currentIndex = candidateNodes.indexOf(event.currentTarget);\n                candidateNodes = context.loop\n                  ? wrapArray(candidateNodes, currentIndex + 1)\n                  : candidateNodes.slice(currentIndex + 1);\n              }\n\n              /**\n               * Imperative focus during keydown is risky so we prevent React's batching updates\n               * to avoid potential bugs. See: https://github.com/facebook/react/issues/20332\n               */\n              setTimeout(() => focusFirst(candidateNodes));\n            }\n          })}\n        >\n          {typeof children === 'function'\n            ? children({ isCurrentTabStop, hasTabStop: currentTabStopId != null })\n            : children}\n        </Primitive.span>\n      </Collection.ItemSlot>\n    );\n  }\n);\n\nRovingFocusGroupItem.displayName = ITEM_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\n// prettier-ignore\nconst MAP_KEY_TO_FOCUS_INTENT: Record<string, FocusIntent> = {\n  ArrowLeft: 'prev', ArrowUp: 'prev',\n  ArrowRight: 'next', ArrowDown: 'next',\n  PageUp: 'first', Home: 'first',\n  PageDown: 'last', End: 'last',\n};\n\nfunction getDirectionAwareKey(key: string, dir?: Direction) {\n  if (dir !== 'rtl') return key;\n  return key === 'ArrowLeft' ? 'ArrowRight' : key === 'ArrowRight' ? 'ArrowLeft' : key;\n}\n\ntype FocusIntent = 'first' | 'last' | 'prev' | 'next';\n\nfunction getFocusIntent(event: React.KeyboardEvent, orientation?: Orientation, dir?: Direction) {\n  const key = getDirectionAwareKey(event.key, dir);\n  if (orientation === 'vertical' && ['ArrowLeft', 'ArrowRight'].includes(key)) return undefined;\n  if (orientation === 'horizontal' && ['ArrowUp', 'ArrowDown'].includes(key)) return undefined;\n  return MAP_KEY_TO_FOCUS_INTENT[key];\n}\n\nfunction focusFirst(candidates: HTMLElement[], preventScroll = false) {\n  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;\n  for (const candidate of candidates) {\n    // if focus is already where we want to go, we don't want to keep going through the candidates\n    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;\n    candidate.focus({ preventScroll });\n    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;\n  }\n}\n\n/**\n * Wraps an array around itself at a given start index\n * Example: `wrapArray(['a', 'b', 'c', 'd'], 2) === ['c', 'd', 'a', 'b']`\n */\nfunction wrapArray<T>(array: T[], startIndex: number) {\n  return array.map<T>((_, index) => array[(startIndex + index) % array.length]!);\n}\n\nconst Root = RovingFocusGroup;\nconst Item = RovingFocusGroupItem;\n\nexport {\n  createRovingFocusGroupScope,\n  //\n  RovingFocusGroup,\n  RovingFocusGroupItem,\n  //\n  Root,\n  Item,\n};\nexport type { RovingFocusGroupProps, RovingFocusItemProps };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}